#!/usr/bin/env ruby

# This script manages selected and installed packages. It can be configured
# with the `~/.config/toolkit` file, which will be autogenerated if it is not
# found when this script is run. An alternate config location can be specified
# with the `TOOLKIT_CONFIG` environment variable.
#
# Author:: Greg Look

require 'optparse'
require 'pathname'

SCRIPT_NAME = File.basename($0)
TOOLKIT_ROOT = Pathname.new(__FILE__).realpath.dirname
PACKAGE_SET_ROOT = TOOLKIT_ROOT + 'packages'

$: << TOOLKIT_ROOT + 'lib'

require 'toolkit'

# set default options
$options = {}
$options[:mount] = Pathname.new(ENV['HOME'])
$options[:config] = Pathname.new(ENV['TOOLKIT_CONFIG'] || (ENV['HOME'] + '.config/toolkit'))

# parse command-line options
options = OptionParser.new do |opts|
  opts.banner = "Usage: #{SCRIPT_NAME} [options] [action] [arguments ...]"
  opts.separator ""
  opts.separator "Options:"
  opts.on('-c', "--config FILE", "Set config file location (default: #{$options[:config]})") {|file| $options[:config] = file }
  opts.on('-m', "--mount DIR", "Set location to install toolkit to (default: #{$options[:mount]})") {|dir| $options[:mount] = dir }
  opts.on('-h', "--help", "Display usage information") { puts opts; exit }
  opts.separator ""
  opts.separator "Actions:"
  opts.separator "    show                 - prints information about selected and installed packages (default action)"
  opts.separator "    enable <package(s)>  - selects the named packages for installation"
  opts.separator "    disable <package(s)> - disables installation of the named packages"
  opts.separator "    default <package(s)> - resets the named packages' selection state"
  opts.separator "    build                - builds links to the selected package files"
end
options.parse!

# helper method to report failures
def fail(msg, code=1)
  STDERR.puts msg
  exit code
end

# load package sets
package_sets = {}
PACKAGE_SET_ROOT.children.each do |path|
  begin
    manifest_path = path + Toolkit::Manifest::MANIFEST_FILE
    if manifest_path.readable?
      package_set = Toolkit::Manifest.new(path)
      package_sets[package_set.name] = package_set
    end
  rescue => e
    STDERR.puts "Failed to load package set from #{path}: #{e.message}"
  end
end

if package_sets.empty?
  STDERR.puts "It looks like you don't have any package sets installed!"
  STDERR.puts "Try cloning some into #{PACKAGE_SET_ROOT}"
end

# initialize toolkit
config = Toolkit::Config.new($options[:config])
$toolkit = Toolkit.new($options[:mount], package_sets, config)

# get action
$action = ARGV.empty? && 'show' || ARGV.shift.downcase

case $action
when 'debug'
  $toolkit.debug

when 'show'
  $toolkit.show

when 'enable'
  fail "Usage: #{SCRIPT_NAME} enable <package> [package ...]" if ARGV.empty?
  ARGV.each {|package| $toolkit.select package, true }
  $toolkit.save
  $toolkit.show

when 'disable'
  fail "Usage: #{SCRIPT_NAME} disable <package> [package ...]" if ARGV.empty?
  ARGV.each {|package| $toolkit.select package, false }
  $toolkit.save
  $toolkit.show

when 'default'
  fail "Usage: #{SCRIPT_NAME} default <package> [package ...]" if ARGV.empty?
  ARGV.each {|package| $toolkit.select package, nil }
  $toolkit.save
  $toolkit.show

when 'build'
  $toolkit.update

else
  fail "Unknown action '#{$action}', try: show, enable, disable, default, build"
end
